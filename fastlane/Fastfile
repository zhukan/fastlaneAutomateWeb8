# Fastfile - iOS App Store è‡ªåŠ¨åŒ–å‘å¸ƒç³»ç»Ÿ
# æ›´å¤šä¿¡æ¯: https://docs.fastlane.tools

default_platform(:ios)

# ==================== å…¨å±€é…ç½® ====================

# ä½¿ç”¨ Scheme åç§°ä½œä¸ºè¾“å‡ºæ–‡ä»¶å
APP_NAME = ENV["SCHEME"] || "App"
OUTPUT_DIRECTORY = "./build"

# ==================== Helper æ–¹æ³• ====================

# ç›´æ¥æ›´æ–° Xcode é¡¹ç›®é…ç½®ä¸­çš„ MARKETING_VERSION
def update_xcodeproj_version(version_number:, xcodeproj:)
  require 'xcodeproj'
  
  # å¤„ç†ç›¸å¯¹è·¯å¾„ï¼šfastlane åœ¨é¡¹ç›®çš„ fastlane/ å­ç›®å½•è¿è¡Œ
  # xcodeproj åœ¨é¡¹ç›®æ ¹ç›®å½•ï¼Œéœ€è¦å‘ä¸Šä¸€çº§
  xcodeproj_path = File.expand_path("../#{xcodeproj}", __dir__)
  
  UI.message "ğŸ” æ‰“å¼€é¡¹ç›®: #{xcodeproj_path}"
  project = Xcodeproj::Project.open(xcodeproj_path)
  
  # éå†æ‰€æœ‰ targets å’Œ configurationsï¼Œæ›´æ–° MARKETING_VERSION
  project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['MARKETING_VERSION'] = version_number
    end
  end
  
  project.save
  UI.success "âœ… å·²æ›´æ–° MARKETING_VERSION ä¸º: #{version_number}"
end

# ==================== å…¨å±€é’©å­ ====================

# æ‰€æœ‰ lane æ‰§è¡Œå‰çš„å‡†å¤‡å·¥ä½œ
before_all do |lane, options|
  # åœ¨ CI ç¯å¢ƒä¸­è‡ªåŠ¨é…ç½®
  setup_ci if ENV['CI']

  # è¾“å‡ºå½“å‰ç¯å¢ƒä¿¡æ¯
  UI.message "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  UI.message "ğŸš€ å¼€å§‹æ‰§è¡Œ Lane: #{lane}"
  UI.message "ğŸ“± Bundle ID: #{ENV['APP_IDENTIFIER_PRODUCTION']}"
  UI.message "ğŸ—ï¸  Scheme: #{ENV['SCHEME']}"
  UI.message "ğŸ“¦ Configuration: #{ENV['CONFIGURATION']}"
  UI.message "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
end

# æ‰€æœ‰ lane æ‰§è¡ŒæˆåŠŸå
after_all do |lane, options|
  UI.success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  UI.success "âœ… Lane #{lane} æ‰§è¡ŒæˆåŠŸ!"
  UI.success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  # å‘é€æˆåŠŸé€šçŸ¥
  send_success_notification(lane: lane)
end

# é”™è¯¯å¤„ç†
error do |lane, exception, options|
  UI.error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  UI.error "âŒ Lane #{lane} æ‰§è¡Œå¤±è´¥!"
  UI.error "é”™è¯¯ä¿¡æ¯: #{exception.message}"
  UI.error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  # å‘é€é”™è¯¯é€šçŸ¥
  send_error_notification(
    lane: lane,
    error: exception.message
  )
end

# ==================== iOS å¹³å° ====================

platform :ios do

  # ========== ç‰ˆæœ¬å·ç®¡ç† ==========

  desc "è‡ªåŠ¨å¢åŠ  Build Number"
  desc "åŸºäº App Store Connect æœ€æ–°ç‰ˆæœ¬è‡ªåŠ¨é€’å¢"
  desc "æ”¯æŒé¦–æ¬¡å‘å¸ƒå’Œæ›´æ–°å‘å¸ƒï¼Œè‡ªåŠ¨æ™ºèƒ½å¤„ç†"
  lane :bump_build do
    # é…ç½® API Key è®¤è¯ï¼ˆå¦‚æœæœ‰é…ç½®ï¼‰
    setup_app_store_connect_api_key
    
    # 1. è·å–æœ¬åœ°å½“å‰ build number ä½œä¸ºåŸºå‡†
    current_local_build = get_build_number(xcodeproj: ENV["PROJECT"]).to_i
    UI.message "ğŸ“± å½“å‰æœ¬åœ° Build Number: #{current_local_build}"
    
    begin
      # 2. å°è¯•ä» App Store Connect è·å–æœ€æ–° build number
      UI.message "ğŸ” æ­£åœ¨æŸ¥è¯¢ App Store Connect..."
      latest_remote_build = app_store_build_number(
        app_identifier: ENV["APP_IDENTIFIER_PRODUCTION"],
        live: false  # false = åŒ…æ‹¬ç­‰å¾…å®¡æ ¸çš„ç‰ˆæœ¬
      )
      
      UI.message "â˜ï¸  è¿œç¨‹æœ€æ–° Build Number: #{latest_remote_build}"
      
      # 3. æ­£å¸¸æ›´æ–°æµç¨‹ï¼šè¿œç¨‹ + 1
      new_build = latest_remote_build + 1
      
      # 4. å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœæœ¬åœ° >= è¿œç¨‹+1ï¼Œä½¿ç”¨æœ¬åœ°+1
      if current_local_build >= new_build
        new_build = current_local_build + 1
        UI.important "âš ï¸  æœ¬åœ° Build (#{current_local_build}) >= è¿œç¨‹ Build (#{latest_remote_build})"
        UI.important "   ä½¿ç”¨æœ¬åœ°å€¼é€’å¢é¿å…å†²çª"
      end
      
      UI.success "âœ… æ›´æ–°å‘å¸ƒæ¨¡å¼"
      
    rescue => ex
      # 5. é¦–æ¬¡å‘å¸ƒé™çº§ç­–ç•¥
      if ex.message.include?("Could not find an app") || 
         ex.message.include?("Could not find a build") ||
         ex.message.include?("No value found")
        UI.important "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        UI.important "ğŸ†• é¦–æ¬¡å‘å¸ƒæ£€æµ‹"
        UI.important "   App Store Connect ä¸­æœªæ‰¾åˆ°ç°æœ‰ Build"
        UI.important "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        
        if current_local_build > 0
          # ä½¿ç”¨æœ¬åœ°ç°æœ‰çš„ build number
          new_build = current_local_build
          UI.message "   ä¿æŒæœ¬åœ° Build Number: #{new_build}"
        else
          # å®Œå…¨æ–°é¡¹ç›®ï¼Œä» 1 å¼€å§‹
          new_build = 1
          UI.message "   ä½¿ç”¨åˆå§‹ Build Number: 1"
        end
        
      else
        # å…¶ä»–é”™è¯¯ï¼ˆç½‘ç»œã€æƒé™ç­‰ï¼‰ï¼Œé‡æ–°æŠ›å‡º
        UI.error "è·å–è¿œç¨‹ Build Number å¤±è´¥: #{ex.message}"
        raise ex
      end
    end
    
    # 6. æ›´æ–°é¡¹ç›®ä¸­çš„ build number
    increment_build_number(
      build_number: new_build,
      xcodeproj: ENV["PROJECT"]
    )
    
    UI.success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    UI.success "ğŸ“ˆ Build Number å·²è®¾ç½®"
    UI.success "   #{current_local_build} â†’ #{new_build}"
    UI.success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  end

  desc "æ›´æ–°ç‰ˆæœ¬å·ï¼ˆä»…ç”¨äºæ›´æ–°å‘å¸ƒï¼‰"
  desc "ä½¿ç”¨æ–¹å¼ï¼š"
  desc "  fastlane bump_version type:patch   # 1.0.0 â†’ 1.0.1"
  desc "  fastlane bump_version type:minor   # 1.0.0 â†’ 1.1.0"
  desc "  fastlane bump_version type:major   # 1.0.0 â†’ 2.0.0"
  desc "  fastlane bump_version version:1.2.3  # æ‰‹åŠ¨æŒ‡å®šç‰ˆæœ¬å·"
  lane :bump_version do |options|
    if options[:version]
      # æ‰‹åŠ¨æŒ‡å®šç‰ˆæœ¬å·
      target_version = ensure_version_format(options[:version])
      
      # æ›´æ–° xcodeproj ä¸­çš„ MARKETING_VERSION
      update_xcodeproj_version(
        version_number: target_version,
        xcodeproj: ENV["PROJECT"]
      )
      
      # å°è¯•åŒæ—¶æ›´æ–° Info.plistï¼ˆå¯é€‰ï¼‰
      begin
        increment_version_number(
          version_number: target_version,
          xcodeproj: ENV["PROJECT"]
        )
      rescue => ex
        UI.important "âš ï¸  agvtool æ›´æ–°å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: #{ex.message}"
      end
      
      new_version = target_version
    else
      # è‡ªåŠ¨é€’å¢ï¼špatch / minor / major
      bump_type = options[:type] || "patch"
      
      # è·å–å½“å‰ç‰ˆæœ¬å·
      current_version = nil
      begin
        current_version = get_version_number(xcodeproj: ENV["PROJECT"])
        UI.message "ğŸ“± å½“å‰ç‰ˆæœ¬: #{current_version}"
      rescue => ex
        UI.error "è¯»å–ç‰ˆæœ¬å·å¤±è´¥: #{ex.message}"
        # è®¾ç½®é»˜è®¤ç‰ˆæœ¬åç›´æ¥è¿”å›
        update_xcodeproj_version(
          version_number: "1.0.0",
          xcodeproj: ENV["PROJECT"]
        )
        UI.success "ğŸ“Š ç‰ˆæœ¬å·å·²è®¾ç½®ä¸º: 1.0.0"
        return
      end
      
      # æ£€æŸ¥å¹¶è§„èŒƒåŒ–ç‰ˆæœ¬å·æ ¼å¼
      if current_version.nil? || current_version.empty? || !current_version.match?(/^\d+\.\d+\.\d+$/)
        UI.important "âš ï¸  ç‰ˆæœ¬å·æ ¼å¼ä¸æ ‡å‡†: '#{current_version}'"
        
        # è§„èŒƒåŒ–å¹¶è®¡ç®—é€’å¢åçš„ç‰ˆæœ¬
        parts = current_version.to_s.split('.').map(&:to_i)
        while parts.length < 3
          parts << 0
        end
        
        # æ ¹æ®é€’å¢ç±»å‹è®¡ç®—æ–°ç‰ˆæœ¬
        case bump_type
        when "major"
          parts[0] += 1
          parts[1] = 0
          parts[2] = 0
        when "minor"
          parts[1] += 1
          parts[2] = 0
        when "patch"
          parts[2] += 1
        end
        
        target_version = parts.join('.')
        UI.important "   é€’å¢ä¸º: #{target_version}"
        
        # æ›´æ–°ç‰ˆæœ¬å·
        update_xcodeproj_version(
          version_number: target_version,
          xcodeproj: ENV["PROJECT"]
        )
        
        # å°è¯•åŒæ­¥ Info.plist
        begin
          increment_version_number(
            version_number: target_version,
            xcodeproj: ENV["PROJECT"]
          )
        rescue => ex
          UI.important "âš ï¸  agvtool æ›´æ–°å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: #{ex.message}"
        end
        
        new_version = target_version
      else
        # ç‰ˆæœ¬å·æ ¼å¼æ­£ç¡®ï¼Œå°è¯•ä½¿ç”¨ increment_version_number é€’å¢
        begin
          increment_version_number(
            bump_type: bump_type,
            xcodeproj: ENV["PROJECT"]
          )
          new_version = get_version_number(xcodeproj: ENV["PROJECT"])
          
          # åŒæ­¥æ›´æ–° xcodeproj ä¸­çš„ MARKETING_VERSION
          update_xcodeproj_version(
            version_number: new_version,
            xcodeproj: ENV["PROJECT"]
          )
        rescue => ex
          # agvtool ä¸å¯ç”¨ï¼Œæ‰‹åŠ¨è®¡ç®—é€’å¢
          UI.important "âš ï¸  agvtool é€’å¢å¤±è´¥ï¼Œä½¿ç”¨æ‰‹åŠ¨è®¡ç®—: #{ex.message}"
          
          parts = current_version.split('.').map(&:to_i)
          case bump_type
          when "major"
            parts[0] += 1
            parts[1] = 0
            parts[2] = 0
          when "minor"
            parts[1] += 1
            parts[2] = 0
          when "patch"
            parts[2] += 1
          end
          
          new_version = parts.join('.')
          
          # ç›´æ¥æ›´æ–° MARKETING_VERSION
          update_xcodeproj_version(
            version_number: new_version,
            xcodeproj: ENV["PROJECT"]
          )
        end
      end
    end

    UI.success "ğŸ“Š ç‰ˆæœ¬å·å·²æ›´æ–°ä¸º: #{new_version}"
  end

  # ========== è¯ä¹¦å’Œç­¾åç®¡ç† ==========

  desc "è‡ªåŠ¨è·å–è¯ä¹¦å’Œæè¿°æ–‡ä»¶"
  desc "ä½¿ç”¨ App Store Connect API Key è‡ªåŠ¨è·å–/åˆ›å»ºè¯ä¹¦"
  lane :setup_certificates do
    UI.message "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    UI.message "ğŸ” è‡ªåŠ¨è·å–è¯ä¹¦å’Œæè¿°æ–‡ä»¶"
    UI.message "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    # ä½¿ç”¨ API Key è®¤è¯
    setup_app_store_connect_api_key
    
    begin
      # 1. è‡ªåŠ¨è·å–/åˆ›å»º Distribution è¯ä¹¦
      UI.message "ğŸ“œ æ£€æŸ¥/è·å–å‘å¸ƒè¯ä¹¦..."
      cert(
        development: false,
        username: ENV["APPLE_ID"]
      )
      
      # 2. è‡ªåŠ¨è·å–/åˆ›å»º Provisioning Profile
      UI.message "ğŸ“„ æ£€æŸ¥/è·å–æè¿°æ–‡ä»¶..."
      sigh(
        app_identifier: ENV["APP_IDENTIFIER_PRODUCTION"],
        readonly: false
      )
      
      UI.success "âœ… è¯ä¹¦å’Œæè¿°æ–‡ä»¶å·²å‡†å¤‡å°±ç»ª"
      
    rescue => ex
      UI.error "âŒ è¯ä¹¦è·å–å¤±è´¥: #{ex.message}"
      UI.important "   è¯·æ£€æŸ¥ API Key é…ç½®å’Œç½‘ç»œè¿æ¥"
      raise ex
    end
  end
  
  desc "åŒæ­¥è¯ä¹¦ï¼ˆMatch æ–¹å¼ï¼‰"
  lane :sync_certificates do |options|
    # æ£€æŸ¥æ˜¯å¦é…ç½®äº† Match
    if ENV["USE_MATCH"] == "true"
      match_type = options[:type] || "appstore"

      match(
        type: match_type,
        readonly: is_ci,
        app_identifier: ENV["APP_IDENTIFIER_PRODUCTION"]
      )

      UI.success "âœ… è¯ä¹¦åŒæ­¥å®Œæˆ"
    else
      UI.important "âš ï¸  æœªå¯ç”¨ Matchï¼Œè·³è¿‡è¯ä¹¦åŒæ­¥"
    end
  end

  # ========== æ„å»º ==========

  desc "æ„å»º IPA æ–‡ä»¶"
  desc "ç¼–è¯‘é¡¹ç›®å¹¶ç”Ÿæˆç”¨äºå‘å¸ƒçš„ IPA æ–‡ä»¶"
  lane :build do |options|
    UI.message "å¼€å§‹æ„å»º #{ENV['SCHEME']}..."

    # 1. è¯ä¹¦ç®¡ç†
    if ENV["USE_MATCH"] == "true"
      # ä½¿ç”¨ Match ç®¡ç†è¯ä¹¦
      sync_certificates(type: "appstore")
    elsif ENV["AUTO_FETCH_CERTIFICATES"] == "true"
      # è‡ªåŠ¨è·å–è¯ä¹¦ï¼ˆæ¨èï¼‰
      setup_certificates
    end

    # 2. æ›´æ–°ä»£ç ç­¾åè®¾ç½®ï¼ˆåªé’ˆå¯¹ä¸» targetï¼Œé¿å…å½±å“ Podsï¼‰
    update_code_signing_settings(
      use_automatic_signing: false,
      path: ENV["PROJECT"],
      team_id: ENV["TEAM_ID"],
      bundle_identifier: ENV["APP_IDENTIFIER_PRODUCTION"],
      profile_name: Actions.lane_context[SharedValues::SIGH_NAME],
      code_sign_identity: "Apple Distribution"
    )
    
    # 3. æ„å»º App
    build_app(
      workspace: ENV["WORKSPACE"],
      scheme: ENV["SCHEME"],
      configuration: ENV["CONFIGURATION"],
      export_method: ENV["EXPORT_METHOD"],
      output_directory: OUTPUT_DIRECTORY,
      output_name: "#{APP_NAME}.ipa",
      clean: true,
      include_bitcode: false,  # Xcode 14+ å·²åºŸå¼ƒ Bitcode
      include_symbols: true,
      # å¯¼å‡ºæ—¶ä½¿ç”¨æ‰‹åŠ¨ç­¾åå’Œ fastlane è·å–çš„æè¿°æ–‡ä»¶
      export_options: {
        method: ENV["EXPORT_METHOD"],
        signingStyle: "manual",
        signingCertificate: "Apple Distribution",
        provisioningProfiles: {
          ENV["APP_IDENTIFIER_PRODUCTION"] => Actions.lane_context[SharedValues::SIGH_NAME]
        }
      }
    )

    # ä½¿ç”¨ build_app ç”Ÿæˆçš„å®é™…è·¯å¾„
    ipa_path = Actions.lane_context[SharedValues::IPA_OUTPUT_PATH]
    
    if ipa_path && File.exist?(ipa_path)
      ipa_size = File.size(ipa_path) / 1024.0 / 1024.0
      UI.success "ğŸ“¦ æ„å»ºå®Œæˆ!"
      UI.success "   æ–‡ä»¶è·¯å¾„: #{ipa_path}"
      UI.success "   æ–‡ä»¶å¤§å°: #{ipa_size.round(2)} MB"
    else
      UI.error "âŒ IPA æ–‡ä»¶ä¸å­˜åœ¨: #{ipa_path}"
      raise "æ„å»ºå¤±è´¥ï¼ŒIPA æ–‡ä»¶æœªç”Ÿæˆ"
    end
  end

  # ========== æµ‹è¯•å‘å¸ƒ (TestFlight) ==========

  desc "å‘å¸ƒåˆ° TestFlight è¿›è¡Œå†…éƒ¨æµ‹è¯•"
  desc "è‡ªåŠ¨æ›´æ–° Build Number å¹¶ä¸Šä¼ åˆ° TestFlight"
  lane :beta do
    UI.message "å¼€å§‹ TestFlight å‘å¸ƒæµç¨‹..."

    # 1. æ›´æ–° Build Number
    bump_build

    # 2. æ„å»º IPA
    build

    # 3. ä¸Šä¼ åˆ° TestFlight
    upload_to_testflight(
      app_identifier: ENV["APP_IDENTIFIER_PRODUCTION"],
      skip_waiting_for_build_processing: true,
      skip_submission: true,
      distribute_external: false,
      changelog: get_changelog,
      notify_external_testers: false
    )

    current_version = get_version_number(xcodeproj: ENV["PROJECT"])
    current_build = get_build_number(xcodeproj: ENV["PROJECT"])

    UI.success "ğŸš€ TestFlight ä¸Šä¼ æˆåŠŸ!"
    UI.success "   ç‰ˆæœ¬: #{current_version} (#{current_build})"
  end

  # ========== æ­£å¼å‘å¸ƒ (App Store) ==========

  desc "å‘å¸ƒåˆ° App Store"
  desc "ä½¿ç”¨æ–¹å¼ï¼š"
  desc "  fastlane release                                # ä½¿ç”¨é»˜è®¤è®¾ç½®"
  desc "  fastlane release version:2.0.0                  # æŒ‡å®šç‰ˆæœ¬å·"
  desc "  fastlane release is_first_release:true          # å…¨æ–°å‘å¸ƒ"
  desc "  fastlane release is_first_release:false         # å‡çº§å‘å¸ƒ"
  desc "  fastlane release submit:true                    # è‡ªåŠ¨æäº¤å®¡æ ¸"
  desc "  fastlane release screenshots:true               # åŒæ—¶ä¸Šä¼ æˆªå›¾"
  lane :release do |options|
    UI.message "å¼€å§‹ App Store å‘å¸ƒæµç¨‹..."

    # ä»å‚æ•°è·å–å‘å¸ƒç±»å‹ï¼ˆä¸å†è‡ªåŠ¨æ£€æµ‹ï¼‰
    is_first_release = options[:is_first_release]
    
    if is_first_release.nil?
      UI.error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      UI.error "âŒ ç¼ºå°‘å¿…éœ€å‚æ•°: is_first_release"
      UI.error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      UI.error ""
      UI.error "è¯·æŒ‡å®šå‘å¸ƒç±»å‹ï¼š"
      UI.error "  å…¨æ–°å‘å¸ƒ: fastlane release is_first_release:true"
      UI.error "  å‡çº§å‘å¸ƒ: fastlane release is_first_release:false"
      UI.error ""
      raise "ç¼ºå°‘å¿…éœ€å‚æ•°: is_first_release"
    end
    
    # è½¬æ¢ä¸ºå¸ƒå°”å€¼ï¼ˆå‘½ä»¤è¡Œä¼ å…¥çš„æ˜¯å­—ç¬¦ä¸²ï¼‰
    is_first_release = (is_first_release.to_s.downcase == 'true')
    
    if is_first_release
      UI.important "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      UI.important "ğŸ†• å…¨æ–°å‘å¸ƒæ¨¡å¼"
      UI.important "   è¿™æ˜¯é¦–æ¬¡å‘å¸ƒæ­¤åº”ç”¨åˆ° App Store"
      UI.important "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    else
      UI.important "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      UI.important "ğŸ”„ å‡çº§å‘å¸ƒæ¨¡å¼"
      UI.important "   æ›´æ–°å·²å‘å¸ƒåˆ° App Store çš„åº”ç”¨"
      UI.important "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    end

    # æ ¹æ®æ˜¯å¦å…¨æ–°å‘å¸ƒï¼Œé‡‡ç”¨ä¸åŒçš„ç‰ˆæœ¬ç®¡ç†ç­–ç•¥
    if is_first_release
      # ===== å…¨æ–°å‘å¸ƒï¼šä½¿ç”¨ Xcode ä¸­å·²è®¾ç½®çš„ç‰ˆæœ¬å· =====
      if options[:version]
        # ç”¨æˆ·æ˜ç¡®æŒ‡å®šäº†ç‰ˆæœ¬å·ï¼Œä½¿ç”¨æŒ‡å®šçš„ç‰ˆæœ¬
        target_version = ensure_version_format(options[:version])
        UI.message "ğŸ¯ ä½¿ç”¨æŒ‡å®šç‰ˆæœ¬å·: #{target_version}"
        
        # æ›´æ–°åˆ°é¡¹ç›®ä¸­
        update_xcodeproj_version(
          version_number: target_version,
          xcodeproj: ENV["PROJECT"]
        )
        
        begin
          increment_version_number(
            version_number: target_version,
            xcodeproj: ENV["PROJECT"]
          )
        rescue => ex
          UI.important "âš ï¸  agvtool æ›´æ–°å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: #{ex.message}"
        end
      else
        # æœªæŒ‡å®šç‰ˆæœ¬å·ï¼šè¯»å– Xcode ä¸­å·²è®¾ç½®çš„ç‰ˆæœ¬å·ï¼Œä¿æŒä¸å˜
        begin
          current_version = get_version_number(xcodeproj: ENV["PROJECT"])
          
          if current_version.nil? || current_version.empty?
            # Xcode ä¸­æ²¡æœ‰è®¾ç½®ç‰ˆæœ¬å·ï¼Œä½¿ç”¨é»˜è®¤å€¼ 1.0.0
            target_version = "1.0.0"
            UI.important "âš ï¸  Xcode ä¸­æœªè®¾ç½®ç‰ˆæœ¬å·ï¼Œä½¿ç”¨é»˜è®¤å€¼: #{target_version}"
            
            update_xcodeproj_version(
              version_number: target_version,
              xcodeproj: ENV["PROJECT"]
            )
            
            begin
              increment_version_number(
                version_number: target_version,
                xcodeproj: ENV["PROJECT"]
              )
            rescue => ex
              UI.important "âš ï¸  agvtool æ›´æ–°å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: #{ex.message}"
            end
          else
            # Xcode ä¸­å·²æœ‰ç‰ˆæœ¬å·ï¼Œè§„èŒƒåŒ–æ ¼å¼å¹¶ä¿æŒ
            target_version = ensure_version_format(current_version)
            
            if target_version != current_version
              UI.important "âš ï¸  ç‰ˆæœ¬å·æ ¼å¼å·²è§„èŒƒåŒ–: #{current_version} â†’ #{target_version}"
              update_xcodeproj_version(
                version_number: target_version,
                xcodeproj: ENV["PROJECT"]
              )
              
              begin
                increment_version_number(
                  version_number: target_version,
                  xcodeproj: ENV["PROJECT"]
                )
              rescue => ex
                UI.important "âš ï¸  agvtool æ›´æ–°å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: #{ex.message}"
              end
            else
              UI.success "âœ… ä½¿ç”¨ Xcode ä¸­å·²è®¾ç½®çš„ç‰ˆæœ¬å·: #{target_version}"
              UI.message "   å…¨æ–°å‘å¸ƒä¿æŒè¯¥ç‰ˆæœ¬å·ä¸å˜"
            end
          end
        rescue => ex
          UI.error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          UI.error "âŒ ç‰ˆæœ¬å·é…ç½®å¤±è´¥"
          UI.error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          UI.error ""
          UI.error "é”™è¯¯ä¿¡æ¯: #{ex.message}"
          UI.error ""
          UI.error "è¯·æ£€æŸ¥ï¼š"
          UI.error "1. é¡¹ç›®è·¯å¾„æ˜¯å¦æ­£ç¡®: #{ENV['PROJECT']}"
          UI.error "2. Xcode â†’ Target â†’ General â†’ Version å­—æ®µ"
          UI.error "3. Build Settings â†’ Marketing Version"
          UI.error ""
          UI.error "æˆ–æ‰‹åŠ¨æŒ‡å®šç‰ˆæœ¬å·ï¼š"
          UI.error "  fastlane release is_first_release:true version:1.0.0"
          UI.error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          raise ex
        end
      end
    else
      # ===== å‡çº§å‘å¸ƒï¼šæ ¹æ®å‚æ•°é€’å¢æˆ–ä¿æŒç‰ˆæœ¬å· =====
      if options[:version]
        # æ‰‹åŠ¨æŒ‡å®šç‰ˆæœ¬å·
        bump_version(version: options[:version])
      elsif options[:type]
        # è‡ªåŠ¨é€’å¢ï¼ˆpatch/minor/majorï¼‰
        bump_version(type: options[:type])
      else
        # ä¸æ›´æ–°ç‰ˆæœ¬å·ï¼Œåªæ›´æ–° Build Number
        current_version = get_version_number(xcodeproj: ENV["PROJECT"])
        UI.message "ğŸ“Š ä¿æŒå½“å‰ç‰ˆæœ¬å·: #{current_version}"
        UI.message "   ä»…æ›´æ–° Build Number"
      end
    end

    # 2. æ›´æ–° Build Number
    bump_build

    # 3. æ„å»º IPA
    build

    # 4. ä¸Šä¼ åˆ° App Store Connect
    upload_to_app_store(
      app_identifier: ENV["APP_IDENTIFIER_PRODUCTION"],
      ipa: "#{OUTPUT_DIRECTORY}/#{APP_NAME}.ipa",
      skip_screenshots: options[:screenshots] != true,
      skip_metadata: options[:metadata] != true,
      submit_for_review: options[:submit] == true,
      automatic_release: false,
      force: true,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

    # 5. å®Œæˆ
    current_version = get_version_number(xcodeproj: ENV["PROJECT"])
    current_build = get_build_number(xcodeproj: ENV["PROJECT"])

    UI.success "ğŸ‰ App Store å‘å¸ƒå®Œæˆ!"
    UI.success "   ç‰ˆæœ¬: #{current_version} (#{current_build})"

    if options[:submit] == true
      UI.success "   å·²è‡ªåŠ¨æäº¤å®¡æ ¸"
    else
      UI.important "âš ï¸  è¯·æ‰‹åŠ¨åœ¨ App Store Connect ä¸­æäº¤å®¡æ ¸"
    end
  end

  # ========== ä¸€é”®å‘å¸ƒ ==========

  desc "ä¸€é”®å®Œæ•´å‘å¸ƒæµç¨‹"
  desc "åŒ…å«æ„å»ºã€ä¸Šä¼ åˆ° App Storeï¼Œä½†ä¸è‡ªåŠ¨æäº¤å®¡æ ¸"
  lane :deploy do
    release(
      screenshots: false,
      metadata: false,
      submit: false
    )
  end

  # ========== è¾…åŠ©åŠŸèƒ½ ==========

  desc "ä¸‹è½½ App Store å…ƒæ•°æ®å’Œæˆªå›¾"
  desc "ä» App Store Connect ä¸‹è½½ç°æœ‰çš„å…ƒæ•°æ®åˆ°æœ¬åœ°"
  lane :download_metadata do
    deliver(
      app_identifier: ENV["APP_IDENTIFIER_PRODUCTION"],
      download_metadata: true,
      download_screenshots: true,
      force: true
    )

    UI.success "âœ… å…ƒæ•°æ®å·²ä¸‹è½½åˆ° fastlane/metadata ç›®å½•"
  end

  desc "ä»…ä¸Šä¼ å…ƒæ•°æ®"
  desc "ä¸ä¸Šä¼  IPAï¼Œä»…æ›´æ–° App Store çš„æ–‡æœ¬å’Œæˆªå›¾"
  lane :upload_metadata do
    upload_to_app_store(
      app_identifier: ENV["APP_IDENTIFIER_PRODUCTION"],
      skip_binary_upload: true,
      skip_screenshots: false,
      force: true
    )

    UI.success "âœ… å…ƒæ•°æ®ä¸Šä¼ å®Œæˆ"
  end

  desc "æ¸…ç†æ„å»ºäº§ç‰©"
  desc "åˆ é™¤ DerivedData å’Œæ„å»ºè¾“å‡ºç›®å½•"
  lane :clean do
    UI.message "å¼€å§‹æ¸…ç†..."

    # æ¸…ç† DerivedData
    clear_derived_data

    # åˆ é™¤æ„å»ºè¾“å‡ºç›®å½•
    sh "rm -rf ../#{OUTPUT_DIRECTORY}" if File.exist?("../#{OUTPUT_DIRECTORY}")

    UI.success "ğŸ§¹ æ¸…ç†å®Œæˆ"
  end

  desc "æŸ¥çœ‹å½“å‰ç‰ˆæœ¬ä¿¡æ¯"
  desc "æ˜¾ç¤ºå½“å‰é¡¹ç›®çš„ç‰ˆæœ¬å·å’Œ Build Number"
  lane :version_info do
    current_version = get_version_number(xcodeproj: ENV["PROJECT"])
    current_build = get_build_number(xcodeproj: ENV["PROJECT"])

    UI.header "ğŸ“± ç‰ˆæœ¬ä¿¡æ¯"
    UI.message "App: #{ENV['APP_IDENTIFIER_PRODUCTION']}"
    UI.message "Version: #{current_version}"
    UI.message "Build: #{current_build}"
    UI.message "Scheme: #{ENV['SCHEME']}"
    UI.message "Configuration: #{ENV['CONFIGURATION']}"
  end

end

# ==================== ç§æœ‰è¾…åŠ©æ–¹æ³• ====================

# ç¡®ä¿ç‰ˆæœ¬å·æ ¼å¼æ­£ç¡®ï¼ˆA.B.C æ ¼å¼ï¼‰
def ensure_version_format(version)
  return version if version.nil? || version.empty?
  
  parts = version.split('.')
  while parts.length < 3
    parts << '0'
  end
  
  parts[0..2].join('.')
end

# é…ç½® App Store Connect API Keyï¼ˆå¦‚æœæœ‰é…ç½®ï¼‰
def setup_app_store_connect_api_key
  # æ£€æŸ¥æ˜¯å¦é…ç½®äº† API Key
  if ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"] && 
     ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"] && 
     ENV["APP_STORE_CONNECT_API_KEY_KEY_FILEPATH"]
    
    UI.message "ğŸ”‘ ä½¿ç”¨ App Store Connect API Key è®¤è¯"
    
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_KEY_FILEPATH"],
      duration: 1200, # 20 åˆ†é’Ÿæœ‰æ•ˆæœŸ
      in_house: false
    )
  else
    UI.message "ğŸ” ä½¿ç”¨ Apple ID å¯†ç è®¤è¯"
  end
end

# è·å–å˜æ›´æ—¥å¿—
def get_changelog
  # æœ¬åœ°é¡¹ç›®æ—  Gitï¼Œä½¿ç”¨é»˜è®¤æ›´æ–°è¯´æ˜
  # å¦‚éœ€è‡ªå®šä¹‰ï¼Œå¯åœ¨ fastlane/changelog.txt ä¸­ç¼–å†™
  changelog_file = File.join(File.dirname(__FILE__), "changelog.txt")

  if File.exist?(changelog_file)
    return File.read(changelog_file).strip
  else
    return "Bug fixes and improvements"
  end
end

# å‘é€æˆåŠŸé€šçŸ¥
def send_success_notification(lane:)
  current_version = get_version_number(xcodeproj: ENV["PROJECT"])
  current_build = get_build_number(xcodeproj: ENV["PROJECT"])

  message = "âœ… #{lane} æ‰§è¡ŒæˆåŠŸ!\nç‰ˆæœ¬: #{current_version} (#{current_build})"

  # Slack é€šçŸ¥
  if ENV["SLACK_WEBHOOK_URL"] && !ENV["SLACK_WEBHOOK_URL"].empty?
    begin
      slack(
        message: message,
        success: true,
        slack_url: ENV["SLACK_WEBHOOK_URL"],
        channel: ENV["SLACK_CHANNEL"] || "#releases",
        payload: {
          "Lane" => lane.to_s,
          "Version" => current_version,
          "Build" => current_build,
          "Time" => Time.now.strftime("%Y-%m-%d %H:%M:%S")
        }
      )
      UI.success "ğŸ“¨ Slack é€šçŸ¥å·²å‘é€"
    rescue => ex
      UI.error "Slack é€šçŸ¥å‘é€å¤±è´¥: #{ex.message}"
    end
  end

  # é’‰é’‰é€šçŸ¥
  if ENV["DINGTALK_ACCESS_TOKEN"] && ENV["DINGTALK_NOTIFICATION_ENABLED"] == "true"
    send_dingtalk_notification(
      title: "ğŸ‰ æ„å»ºæˆåŠŸ",
      message: message,
      success: true
    )
  end
end

# å‘é€é”™è¯¯é€šçŸ¥
def send_error_notification(lane:, error:)
  message = "âŒ #{lane} æ‰§è¡Œå¤±è´¥!\né”™è¯¯: #{error}"

  # Slack é€šçŸ¥
  if ENV["SLACK_WEBHOOK_URL"] && !ENV["SLACK_WEBHOOK_URL"].empty?
    begin
      slack(
        message: message,
        success: false,
        slack_url: ENV["SLACK_WEBHOOK_URL"],
        channel: ENV["SLACK_CHANNEL"] || "#releases",
        payload: {
          "Lane" => lane.to_s,
          "Error" => error,
          "Time" => Time.now.strftime("%Y-%m-%d %H:%M:%S")
        }
      )
      UI.success "ğŸ“¨ Slack é”™è¯¯é€šçŸ¥å·²å‘é€"
    rescue => ex
      UI.error "Slack é€šçŸ¥å‘é€å¤±è´¥: #{ex.message}"
    end
  end

  # é’‰é’‰é€šçŸ¥
  if ENV["DINGTALK_ACCESS_TOKEN"] && ENV["DINGTALK_NOTIFICATION_ENABLED"] == "true"
    send_dingtalk_notification(
      title: "âŒ æ„å»ºå¤±è´¥",
      message: message,
      success: false
    )
  end
end

# é’‰é’‰é€šçŸ¥ï¼ˆè‡ªå®šä¹‰å®ç°ï¼‰
def send_dingtalk_notification(title:, message:, success:)
  require 'net/http'
  require 'json'

  url = URI("https://oapi.dingtalk.com/robot/send?access_token=#{ENV['DINGTALK_ACCESS_TOKEN']}")

  # æ„å»º Markdown æ¶ˆæ¯
  markdown_text = "### #{title}\n\n#{message}\n\n> ğŸ“… æ—¶é—´: #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}"

  payload = {
    msgtype: "markdown",
    markdown: {
      title: title,
      text: markdown_text
    }
  }

  http = Net::HTTP.new(url.host, url.port)
  http.use_ssl = true
  request = Net::HTTP::Post.new(url)
  request["Content-Type"] = "application/json"
  request.body = JSON.generate(payload)

  response = http.request(request)

  if response.code == "200"
    UI.success "ğŸ“¨ é’‰é’‰é€šçŸ¥å·²å‘é€"
  else
    UI.error "é’‰é’‰é€šçŸ¥å‘é€å¤±è´¥: #{response.code}"
  end
rescue => ex
  UI.error "é’‰é’‰é€šçŸ¥å‘é€å¼‚å¸¸: #{ex.message}"
end
